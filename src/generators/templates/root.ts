import type { ProjectConfig } from '../../types';
import { commentBlock, joinSections } from '../utils';

/**
 * Generate root main.tf with module calls
 */
export function generateRootMain(project: ProjectConfig): string {
  const sections: string[] = [];

  sections.push(`${commentBlock('Terraform Configuration', 'Generated by Terraform Builder')}

# This file contains the root module configuration that orchestrates
# all the child modules for your infrastructure.`);

  // Networking Module
  if (project.services.vpc) {
    const hasSubnets = project.services.subnets !== null;
    sections.push(`${commentBlock('Networking Module', 'VPC, subnets, and network infrastructure')}

module "networking" {
  source = "./modules/networking"

  project_name = var.project_name
  vpc_cidr     = var.vpc_cidr${hasSubnets ? `
  public_subnet_cidrs  = var.public_subnet_cidrs
  private_subnet_cidrs = var.private_subnet_cidrs
  availability_zones   = var.availability_zones` : ''}
  tags         = local.common_tags
}`);
  }

  // Security Module
  if (project.services.security_groups) {
    sections.push(`${commentBlock('Security Module', 'Security groups for network access control')}

module "security" {
  source = "./modules/security"

  project_name = var.project_name
  vpc_id       = module.networking.vpc_id
  tags         = local.common_tags

  depends_on = [module.networking]
}`);
  }

  // IAM Module
  if (project.services.iam) {
    const hasS3 = project.services.s3 !== null && project.services.iam.s3_access;
    sections.push(`${commentBlock('IAM Module', 'Roles, policies, and instance profiles')}

module "iam" {
  source = "./modules/iam"

  project_name        = var.project_name
  role_name           = var.iam_role_name
  managed_policy_arns = var.managed_policy_arns${hasS3 ? `
  s3_bucket_arn       = module.storage.bucket_arn` : ''}
  tags                = local.common_tags
}`);
  }

  // Storage Module
  if (project.services.s3) {
    sections.push(`${commentBlock('Storage Module', 'S3 buckets and related resources')}

module "storage" {
  source = "./modules/storage"

  project_name  = var.project_name
  bucket_prefix = var.s3_bucket_prefix
  tags          = local.common_tags
}`);
  }

  // Database Module
  if (project.services.rds) {
    sections.push(`${commentBlock('Database Module', 'RDS instances and related resources')}

module "database" {
  source = "./modules/database"

  project_name               = var.project_name
  vpc_id                     = module.networking.vpc_id
  subnet_ids                 = module.networking.private_subnet_ids
  allowed_security_group_ids = []
  tags                       = local.common_tags

  depends_on = [module.networking]
}`);
  }

  // Serverless Module (Lambda)
  if (project.services.lambda) {
    const hasVPCFunction = project.services.lambda.functions.some(f => f.vpc_enabled);
    sections.push(`${commentBlock('Serverless Module', 'Lambda functions')}

module "serverless" {
  source = "./modules/serverless"

  project_name = var.project_name${hasVPCFunction && project.services.vpc ? `
  public_subnet_ids         = module.networking.public_subnet_ids
  private_subnet_ids        = module.networking.private_subnet_ids
  lambda_security_group_ids = [module.security.lambda_security_group_id]` : ''}
  tags         = local.common_tags
}`);
  }

  // API Module
  if (project.services.api_gateway) {
    sections.push(`${commentBlock('API Module', 'API Gateway endpoints')}

module "api" {
  source = "./modules/api"

  project_name          = var.project_name
  api_name              = var.api_name
  lambda_invoke_arns    = module.serverless.function_arns
  lambda_function_names = { for k, v in module.serverless.function_arns : k => split(":", v)[6] }
  tags                  = local.common_tags

  depends_on = [module.serverless]
}`);
  }

  // Messaging Module (SQS + SNS)
  if (project.services.sqs || project.services.sns) {
    sections.push(`${commentBlock('Messaging Module', 'SQS queues and SNS topics')}

module "messaging" {
  source = "./modules/messaging"

  project_name = var.project_name
  tags         = local.common_tags
}`);
  }

  // Events Module
  if (project.services.eventbridge) {
    const hasLambdaTargets = project.services.eventbridge.rules.some(r => r.targets.some(t => t.type === 'lambda'));
    const hasSQSTargets = project.services.eventbridge.rules.some(r => r.targets.some(t => t.type === 'sqs'));
    
    sections.push(`${commentBlock('Events Module', 'EventBridge rules and targets')}

module "events" {
  source = "./modules/events"

  project_name = var.project_name${hasLambdaTargets && project.services.lambda ? `
  lambda_function_arns  = module.serverless.function_arns
  lambda_function_names = { for k, v in module.serverless.function_arns : k => split(":", v)[6] }` : ''}${hasSQSTargets && project.services.sqs ? `
  sqs_queue_arns        = module.messaging.sqs_queue_arns` : ''}
  tags                  = local.common_tags
}`);
  }

  // Monitoring Module
  if (project.services.cloudwatch) {
    sections.push(`${commentBlock('Monitoring Module', 'CloudWatch logs, alarms, and dashboards')}

module "monitoring" {
  source = "./modules/monitoring"

  project_name = var.project_name
  tags         = local.common_tags
}`);
  }

  // CDN Module
  if (project.services.cloudfront) {
    sections.push(`${commentBlock('CDN Module', 'CloudFront distribution')}

module "cdn" {
  source = "./modules/cdn"

  project_name                   = var.project_name
  distribution_comment           = var.cloudfront_comment
  s3_bucket_id                   = module.storage.bucket_id
  s3_bucket_arn                  = module.storage.bucket_arn
  s3_bucket_regional_domain_name = module.storage.bucket_domain_name
  tags                           = local.common_tags

  depends_on = [module.storage]
}`);
  }

  // Email Module
  if (project.services.ses) {
    sections.push(`${commentBlock('Email Module', 'SES email identities and configuration')}

module "email" {
  source = "./modules/email"

  project_name           = var.project_name
  configuration_set_name = var.ses_configuration_set_name
  tags                   = local.common_tags
}`);
  }

  // Compute Module (EC2)
  if (project.services.ec2) {
    const hasIAM = project.services.iam !== null;
    sections.push(`${commentBlock('Compute Module', 'EC2 instances and related resources')}

module "compute" {
  source = "./modules/compute"

  project_name        = var.project_name
  vpc_id              = module.networking.vpc_id
  subnet_id           = module.networking.public_subnet_ids[0]
  instance_type       = var.instance_type
  associate_public_ip = var.associate_public_ip
  root_volume_size    = var.root_volume_size${project.services.ec2.key_pair_name ? `
  key_pair_name       = var.key_pair_name` : ''}${hasIAM ? `
  instance_profile_name = module.iam.instance_profile_name` : ''}
  tags                = local.common_tags

  depends_on = [module.networking${hasIAM ? ', module.iam' : ''}]
}`);
  }

  return joinSections(...sections);
}

/**
 * Generate root variables.tf
 */
export function generateRootVariables(project: ProjectConfig): string {
  const sections: string[] = [];

  // Project variables
  sections.push(`${commentBlock('Project Variables')}

variable "project_name" {
  description = "Name of the project, used for resource naming and tagging"
  type        = string
  default     = "${project.name}"
}

variable "aws_region" {
  description = "AWS region to deploy resources"
  type        = string
  default     = "${project.region}"
}

variable "environment" {
  description = "Environment name (dev, staging, prod)"
  type        = string
  default     = "${project.environment}"
}`);

  // VPC variables
  if (project.services.vpc) {
    sections.push(`${commentBlock('Networking Variables')}

variable "vpc_cidr" {
  description = "CIDR block for the VPC"
  type        = string
  default     = "${project.services.vpc.cidr_block}"
}`);
  }

  // Subnet variables
  if (project.services.subnets) {
    sections.push(`variable "public_subnet_cidrs" {
  description = "CIDR blocks for public subnets"
  type        = list(string)
  default     = ${JSON.stringify(project.services.subnets.public_subnet_cidrs)}
}

variable "private_subnet_cidrs" {
  description = "CIDR blocks for private subnets"
  type        = list(string)
  default     = ${JSON.stringify(project.services.subnets.private_subnet_cidrs)}
}

variable "availability_zones" {
  description = "Availability zones for subnet distribution"
  type        = list(string)
  default     = ${JSON.stringify(project.services.subnets.availability_zones)}
}`);
  }

  // EC2 variables
  if (project.services.ec2) {
    sections.push(`${commentBlock('Compute Variables')}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "${project.services.ec2.instance_type}"
}

variable "associate_public_ip" {
  description = "Whether to associate a public IP with the EC2 instance"
  type        = bool
  default     = ${project.services.ec2.associate_public_ip}
}

variable "root_volume_size" {
  description = "Size of the root EBS volume in GB"
  type        = number
  default     = ${project.services.ec2.root_volume_size}
}`);

    if (project.services.ec2.key_pair_name) {
      sections.push(`variable "key_pair_name" {
  description = "Name of the EC2 key pair for SSH access"
  type        = string
  default     = "${project.services.ec2.key_pair_name}"
}`);
    }
  }

  // S3 variables
  if (project.services.s3) {
    sections.push(`${commentBlock('Storage Variables')}

variable "s3_bucket_prefix" {
  description = "Prefix for S3 bucket name (will be suffixed with random ID)"
  type        = string
  default     = "${project.services.s3.bucket_prefix || project.name}"
}`);
  }

  // IAM variables
  if (project.services.iam) {
    sections.push(`${commentBlock('IAM Variables')}

variable "iam_role_name" {
  description = "Name of the IAM role"
  type        = string
  default     = "${project.services.iam.role_name || `${project.name}-role`}"
}

variable "managed_policy_arns" {
  description = "List of managed policy ARNs to attach"
  type        = list(string)
  default     = ${JSON.stringify(project.services.iam.managed_policy_arns)}
}`);
  }

  // API Gateway variables
  if (project.services.api_gateway) {
    sections.push(`${commentBlock('API Variables')}

variable "api_name" {
  description = "Name of the API Gateway"
  type        = string
  default     = "${project.services.api_gateway.name || `${project.name}-api`}"
}`);
  }

  // CloudFront variables
  if (project.services.cloudfront) {
    sections.push(`${commentBlock('CDN Variables')}

variable "cloudfront_comment" {
  description = "Comment for the CloudFront distribution"
  type        = string
  default     = "${project.services.cloudfront.comment || `${project.name} CDN`}"
}`);
  }

  // SES variables
  if (project.services.ses) {
    sections.push(`${commentBlock('Email Variables')}

variable "ses_configuration_set_name" {
  description = "Name of the SES configuration set"
  type        = string
  default     = "${project.services.ses.configuration_set_name || `${project.name}-ses-config`}"
}`);
  }

  return joinSections(...sections);
}

/**
 * Generate root outputs.tf
 */
export function generateRootOutputs(project: ProjectConfig): string {
  const sections: string[] = [];

  sections.push(`${commentBlock('Root Module Outputs')}`);

  // Networking outputs
  if (project.services.vpc) {
    sections.push(`output "vpc_id" {
  description = "ID of the VPC"
  value       = module.networking.vpc_id
}`);
  }

  if (project.services.subnets) {
    if (project.services.subnets.public_subnet_cidrs.length > 0) {
      sections.push(`output "public_subnet_ids" {
  description = "IDs of the public subnets"
  value       = module.networking.public_subnet_ids
}`);
    }
    if (project.services.subnets.private_subnet_cidrs.length > 0) {
      sections.push(`output "private_subnet_ids" {
  description = "IDs of the private subnets"
  value       = module.networking.private_subnet_ids
}`);
    }
  }

  // EC2 outputs
  if (project.services.ec2) {
    sections.push(`output "ec2_instance_id" {
  description = "ID of the EC2 instance"
  value       = module.compute.instance_id
}

output "ec2_public_ip" {
  description = "Public IP address of the EC2 instance"
  value       = module.compute.instance_public_ip
}`);
  }

  // Lambda outputs
  if (project.services.lambda) {
    sections.push(`output "lambda_function_arns" {
  description = "ARNs of the Lambda functions"
  value       = module.serverless.function_arns
}`);
  }

  // RDS outputs
  if (project.services.rds) {
    sections.push(`output "rds_endpoint" {
  description = "Endpoint of the RDS instance"
  value       = module.database.db_instance_endpoint
}

output "rds_credentials_secret_arn" {
  description = "ARN of the secret containing database credentials"
  value       = module.database.db_credentials_secret_arn
}`);
  }

  // S3 outputs
  if (project.services.s3) {
    sections.push(`output "s3_bucket_name" {
  description = "Name of the S3 bucket"
  value       = module.storage.bucket_name
}

output "s3_bucket_arn" {
  description = "ARN of the S3 bucket"
  value       = module.storage.bucket_arn
}`);
  }

  // API Gateway outputs
  if (project.services.api_gateway) {
    sections.push(`output "api_endpoint" {
  description = "Endpoint URL of the API Gateway"
  value       = module.api.api_endpoint
}`);
  }

  // CloudFront outputs
  if (project.services.cloudfront) {
    sections.push(`output "cloudfront_domain_name" {
  description = "Domain name of the CloudFront distribution"
  value       = module.cdn.distribution_domain_name
}`);
  }

  // IAM outputs
  if (project.services.iam) {
    sections.push(`output "iam_role_arn" {
  description = "ARN of the IAM role"
  value       = module.iam.role_arn
}`);
  }

  return joinSections(...sections);
}

/**
 * Generate versions.tf
 */
export function generateVersions(): string {
  return `${commentBlock('Terraform and Provider Versions')}

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0"
    }
  }
}

provider "aws" {
  region = var.aws_region

  default_tags {
    tags = {
      ManagedBy = "Terraform"
      Project   = var.project_name
    }
  }
}`;
}

/**
 * Generate terraform.tfvars
 */
export function generateTfvars(project: ProjectConfig): string {
  const lines: string[] = [
    `${commentBlock('Terraform Variable Values')}`,
    '',
    `project_name = "${project.name}"`,
    `aws_region   = "${project.region}"`,
    `environment  = "${project.environment}"`,
  ];

  if (project.services.vpc) {
    lines.push(`vpc_cidr     = "${project.services.vpc.cidr_block}"`);
  }

  if (project.services.subnets) {
    lines.push(
      `public_subnet_cidrs  = ${JSON.stringify(project.services.subnets.public_subnet_cidrs)}`
    );
    lines.push(
      `private_subnet_cidrs = ${JSON.stringify(project.services.subnets.private_subnet_cidrs)}`
    );
    lines.push(
      `availability_zones   = ${JSON.stringify(project.services.subnets.availability_zones)}`
    );
  }

  if (project.services.ec2) {
    lines.push(`instance_type       = "${project.services.ec2.instance_type}"`);
    lines.push(`associate_public_ip = ${project.services.ec2.associate_public_ip}`);
    lines.push(`root_volume_size    = ${project.services.ec2.root_volume_size}`);
    if (project.services.ec2.key_pair_name) {
      lines.push(`key_pair_name       = "${project.services.ec2.key_pair_name}"`);
    }
  }

  if (project.services.s3) {
    lines.push(
      `s3_bucket_prefix    = "${project.services.s3.bucket_prefix || project.name}"`
    );
  }

  if (project.services.iam) {
    lines.push(
      `iam_role_name       = "${project.services.iam.role_name || `${project.name}-role`}"`
    );
  }

  return lines.join('\n');
}

/**
 * Generate locals.tf for common tags
 */
export function generateLocals(): string {
  return `${commentBlock('Local Values')}

locals {
  common_tags = {
    Project     = var.project_name
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
}`;
}
